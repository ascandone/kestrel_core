import Basics.{Bool(..), (+), (-), (>=), (<=)}
import Tuple.{Tuple2(..)}
import Maybe.{Maybe(..)}

pub(..) type List<a> {
  Nil,
  Cons(a, List<a>),
}

pub let range = fn from, to {
  if from >= to {
    Nil
  } else {
    from :: range(from + 1, to)
  }
}

pub let map = fn lst, f {
  match lst {
    Nil => Nil,
    hd :: tl => hd :: map(tl, f)
  }
}

pub let map2 = fn lst1, lst2, f {
  match Tuple2(lst1, lst2) {
    (Cons(hd1, tl1), Cons(hd2, tl2)) => f(hd1, hd2) :: map2(tl1, tl2, f),
    _ => Nil,
  }
}

pub let filter = fn lst, pred {
  match lst {
    Nil => Nil,
    hd :: tl =>
      if pred(hd) {
        hd :: filter(tl, pred)
      } else {
        filter(tl, pred)
      }
  }
}

pub let reduce = fn lst, acc, f {
  match lst {
    Nil => acc,
    hd :: tl => reduce(lst, f(acc, hd), f),
  }
}

pub let reduce_right = fn lst, acc, f {
  match lst {
    Nil => acc,
    hd :: tl => f(hd, reduce_right(tl, acc, f)),
  }
}

pub let concat = fn lst1, lst2 {
  reduce_right(lst1, lst2, Cons)
}

pub let sum_ints = fn lst {
  reduce(lst, 0, fn a, b { a + b })
}

pub let flatten = fn lst {
  reduce_right(lst, Nil, concat)
}

pub let flat_map = fn lst, f{
  lst
  |> map(f)
  |> flatten()
}

pub let filter_map = fn lst, f {
  reduce_right(lst, Nil, fn x, xs {
    match f(x) {
      Nothing => xs,
      Just(hd) => Cons(hd, xs),
    }
  })
}

pub let take = fn lst, n {
  match lst {
    Nil => Nil,
    hd :: tl =>
      if n <= 0 {
        Nil
      } else {
        hd :: take(tl, n - 1)
      }
  }
}

pub let drop = fn lst, n {
  if n <= 0 {
    lst
  } else {
    match lst {
      Nil => Nil,
      _ :: tl => drop(tl, n - 1),
    }
  }
}

pub let is_empty = fn lst {
  match lst {
    Nil => True,
    Cons(_, _) => False,
  }
}

pub let length = fn lst {
  reduce(lst, 0, fn acc, _ { acc + 1 })
}

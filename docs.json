{"version":"0.0.1","modules":{"Basics":{"moduleName":"Basics","items":[{"type":"adt","name":"Float","params":[]},{"type":"value","name":"+.","signature":"Fn(Float, Float) -> Float"},{"type":"value","name":"-.","signature":"Fn(Float, Float) -> Float"},{"type":"value","name":"*.","signature":"Fn(Float, Float) -> Float"},{"type":"value","name":"/.","signature":"Fn(Float, Float) -> Float"},{"type":"adt","name":"Int","params":[]},{"type":"value","name":"+","signature":"Fn(Int, Int) -> Int"},{"type":"value","name":"-","signature":"Fn(Int, Int) -> Int"},{"type":"value","name":"*","signature":"Fn(Int, Int) -> Int"},{"type":"value","name":"/","signature":"Fn(Int, Int) -> Int"},{"type":"value","name":"^","signature":"Fn(Int, Int) -> Int"},{"type":"value","name":"%","signature":"Fn(Int, Int) -> Int"},{"type":"adt","name":"Bool","params":[],"variants":[{"name":"True","args":[]},{"name":"False","args":[]}]},{"type":"value","name":"&&","signature":"Fn(Bool, Bool) -> Bool"},{"type":"value","name":"||","signature":"Fn(Bool, Bool) -> Bool"},{"type":"value","name":"!","signature":"Fn(Bool) -> Bool"},{"type":"value","name":"==","signature":"Fn(a, a) -> Bool"},{"type":"value","name":"!=","signature":"Fn(a, a) -> Bool"},{"type":"value","name":">","signature":"Fn(a, a) -> Bool"},{"type":"value","name":">=","signature":"Fn(a, a) -> Bool"},{"type":"value","name":"<","signature":"Fn(a, a) -> Bool"},{"type":"value","name":"<=","signature":"Fn(a, a) -> Bool"},{"type":"adt","name":"Unit","params":[],"variants":[{"name":"Unit","args":[]}]}]},"String":{"moduleName":"String","items":[{"type":"adt","name":"String","params":[]},{"type":"value","name":"<>","signature":"Fn(String, String) -> String"},{"type":"value","name":"from_int","signature":"Fn(Int) -> String"}]},"Tuple":{"moduleName":"Tuple","items":[{"type":"adt","name":"Tuple2","params":["a","b"],"variants":[{"name":"Tuple2","args":["a","b"]}]},{"type":"value","name":"first","signature":"Fn((a, b)) -> a"},{"type":"value","name":"second","signature":"Fn((a, b)) -> b"},{"type":"adt","name":"Tuple3","params":["a","b","c"],"variants":[{"name":"Tuple3","args":["a","b","c"]}]},{"type":"adt","name":"Tuple4","params":["a","b","c","d"],"variants":[{"name":"Tuple4","args":["a","b","c","d"]}]}]},"Maybe":{"moduleName":"Maybe","items":[{"type":"adt","name":"Maybe","params":["a"],"docComment":" A type representing an optional value.\n","variants":[{"name":"Just","args":["a"]},{"name":"Nothing","args":[]}]},{"type":"value","name":"map","signature":"Fn(Maybe<a>, Fn(a) -> b) -> Maybe<b>"},{"type":"value","name":"and_then","signature":"Fn(Maybe<a>, Fn(a) -> Maybe<b>) -> Maybe<b>"},{"type":"value","name":"map2","signature":"Fn(Maybe<a>, Maybe<b>, Fn(a, b) -> c) -> Maybe<c>"},{"type":"value","name":"map3","signature":"Fn(Maybe<a>, Maybe<b>, Maybe<c>, Fn(a, b, c) -> d) -> Maybe<d>"},{"type":"value","name":"with_default","signature":"Fn(Maybe<a>, a) -> a"}]},"Result":{"moduleName":"Result","items":[{"type":"adt","name":"Result","params":["a","err"],"docComment":" A type representing a value that could be either succesful or not.\n","variants":[{"name":"Ok","args":["a"]},{"name":"Err","args":["err"]}]},{"type":"value","name":"map","signature":"Fn(Result<a, b>, Fn(a) -> c) -> Result<c, b>"},{"type":"value","name":"map_err","signature":"Fn(Result<a, b>, Fn(b) -> c) -> Result<a, c>"},{"type":"value","name":"and_then","signature":"Fn(Result<a, b>, Fn(a) -> Result<c, b>) -> Result<c, b>"}]},"List":{"moduleName":"List","items":[{"type":"adt","name":"List","params":["a"],"variants":[{"name":"Nil","args":[]},{"name":"Cons","args":["a","List<a>"]}]},{"type":"value","name":"range","signature":"Fn(Int, Int) -> List<Int>"},{"type":"value","name":"map","signature":"Fn(List<a>, Fn(a) -> b) -> List<b>"},{"type":"value","name":"map2","signature":"Fn(List<a>, List<b>, Fn(a, b) -> c) -> List<c>"},{"type":"value","name":"find","signature":"Fn(List<a>, Fn(a) -> Bool) -> Maybe<a>"},{"type":"value","name":"filter","signature":"Fn(List<a>, Fn(a) -> Bool) -> List<a>"},{"type":"value","name":"reduce","signature":"Fn(List<a>, b, Fn(b, a) -> b) -> b"},{"type":"value","name":"reduce_right","signature":"Fn(List<a>, b, Fn(a, b) -> b) -> b"},{"type":"value","name":"concat","signature":"Fn(List<a>, List<a>) -> List<a>"},{"type":"value","name":"sum_ints","signature":"Fn(List<Int>) -> Int"},{"type":"value","name":"flatten","signature":"Fn(List<List<a>>) -> List<a>"},{"type":"value","name":"flat_map","signature":"Fn(List<a>, Fn(a) -> List<b>) -> List<b>"},{"type":"value","name":"filter_map","signature":"Fn(List<a>, Fn(a) -> Maybe<b>) -> List<b>"},{"type":"value","name":"take","signature":"Fn(List<a>, Int) -> List<a>"},{"type":"value","name":"drop","signature":"Fn(List<a>, Int) -> List<a>"},{"type":"value","name":"is_empty","signature":"Fn(List<a>) -> Bool"},{"type":"value","name":"length","signature":"Fn(List<a>) -> Int"},{"type":"value","name":"zip","signature":"Fn(List<a>, List<b>) -> List<(a, b)>"}]},"Task":{"moduleName":"Task","items":[{"type":"adt","name":"Task","params":["a"],"docComment":" A task represents a computation (either synchronous or asynchronous) that yiels a value of type `a`.\n Unlike javascript's `Promise`, creating a `Task` doesn't actually do anything.\n The only way to actually run the task is to assign it to the `main` function of the entrypoint module.\n\n Another difference from `Promise` is that `Task` doesn't encode failure:\n to represent a `Task` that might yield an error value you can use the `Task<Result<value, error>>` type.\n Also unlike `Promise`, a task might either be a synchronous operation or a microtask.\n"},{"type":"value","name":"of","signature":"Fn(a) -> Task<a>","docComment":" Lift a value into a `Task`.\n The resulting `Task` might be either synchronous or asynchronous (the behaviour is unspecified).\n"},{"type":"value","name":"never","signature":"Task<a>","docComment":" A task that never resolves.\n"},{"type":"value","name":"await","signature":"Fn(Task<a>, Fn(a) -> Task<b>) -> Task<b>","docComment":" Use the result of a `Task` to create a new `Task`. This function does not execute the `Task`, it only describes a new computation. It is the main primitive to (_sequentially_) chain computation.\n\n ```kestrel\n IO.readline\n |> Task.await(fn value {\n   IO.println(\"Input: \" <> value)\n })\n ```\n"},{"type":"value","name":"map","signature":"Fn(Task<a>, Fn(a) -> b) -> Task<b>"},{"type":"value","name":"sleep","signature":"Fn(Int) -> Task<Unit>","docComment":" Pause the execution for the given number of milliseconds\n"},{"type":"adt","name":"Id","params":[],"docComment":" Identifier of a forked `Task`.\n"},{"type":"value","name":"fork","signature":"Fn(Task<Unit>) -> Task<Id>","docComment":" Run the given computation concurrently.\n The `Id` is returned synchronously, thus there is no way to receive data from the forked `Task` or wait for it to finish.\n In order to accomplish that, the `MVar` synchronization primitive is provided in the `MVar` module.\n\n `fork` is a low-level primitive and you probably might want to use the higher-level `Async`Â module to perform concurrent computation.\n"},{"type":"value","name":"kill","signature":"Fn(Id) -> Task<Unit>","docComment":" Kill the computation with the given `Id`. Cancellation will be propagated recursively though its forks and awaited tasks.\n For example:\n ```kestrel\n pub let main = {\n   let#await task_id = Task.fork({\n     let#await _unit = Task.sleep(2000);\n     Task.println(\"Finished sleeping\")\n   });\n   // Killing this computation prevents the\n   // message to be printed\n   Task.kill(task_id)\n }\n ```\n \n Killing a terminated computation is a noop.\n"},{"type":"value","name":"await_ok","signature":"Fn(Task<Result<a, b>>, Fn(a) -> Task<Result<c, b>>) -> Task<Result<c, b>>"},{"type":"value","name":"none","signature":"Task<Unit>","docComment":" A task that does not do anything.\n Same as `Task.of(Unit)`.\n"}]},"MVar":{"moduleName":"MVar","items":[{"type":"adt","name":"MVar","params":["a"],"docComment":" A `MVar` is a synchronization primitives, useful for communicating from different forked tasks.\n Represents a mutable cell that can either be empty or filled with a value of type `a`.\n"},{"type":"value","name":"empty","signature":"Task<MVar<a>>","docComment":" Create an empty `MVar`\n"},{"type":"value","name":"put","signature":"Fn(MVar<a>, a) -> Task<Unit>","docComment":" Put a value into the given `MVar`.\n If the `MVar` is filled, it will block until it is possible to put.\n"},{"type":"value","name":"take","signature":"Fn(MVar<a>) -> Task<a>","docComment":" Take the value from the given `MVar`.\n If the `MVar` is not filled, it will block until it is possible to take.\n"},{"type":"value","name":"of","signature":"Fn(a) -> Task<MVar<a>>","docComment":" Create a `MVar` filled with the given value.\n"},{"type":"value","name":"update_returning","signature":"Fn(MVar<a>, Fn(a) -> (b, a)) -> Task<b>"}]},"Async":{"moduleName":"Async","items":[{"type":"value","name":"both","signature":"Fn(Task<a>, Task<b>) -> Task<(a, b)>","docComment":" Run the two tasks concurrently and collect the results.\n\n ```kestrel\n pub let main = {\n   let#await (a, b) = Async.both(\n     Task.map(Task.sleep(1000), fn _ {\n       0\n     }),\n     Task.map(Task.sleep(1000), fn _ {\n       1\n     }),\n   );\n   // Resolves with a=0 and b=1\n   // in 1 second instead of 2\n   Task.none\n }\n ```\n"},{"type":"value","name":"both_ok","signature":"Fn(Task<Result<a, b>>, Task<Result<a, b>>) -> Task<Result<(a, a), b>>","docComment":" Run the two `Task`s concurrently.\n Return `Ok` if both `Task`s succeeed, otherwise return `Err` with the first task that fails, and cancel the other.\n"},{"type":"value","name":"race","signature":"Fn(List<Task<a>>) -> Task<a>","docComment":" Run the tasks concurrently and yield the value of the first `Task` to complete.\n All the other tasks are cancelled.\n\n ```kestrel\n pub let main = {\n   let#await a = Async.race([\n     Task.map(Task.sleep(1000), fn _ {\n       0\n     }),\n     Task.map(Task.sleep(200), fn _ {\n       1\n     }),\n   ]);\n   // Resolves with a=1 in 200ms\n   Task.none\n }\n ```\n"}],"moduleDoc":" This module contains a bunch of utilities for handling concurrency operations\n"},"Debug":{"moduleName":"Debug","items":[{"type":"value","name":"inspect","signature":"Fn(a) -> String"},{"type":"value","name":"todo","signature":"Fn(String) -> a"}],"moduleDoc":" Debugging utilities\n"},"Expect":{"moduleName":"Expect","items":[{"type":"adt","name":"Expectation","params":[]},{"type":"value","name":"pass","signature":"Expectation"},{"type":"value","name":"equals","signature":"Fn(a, a) -> Expectation"},{"type":"value","name":"to_result","signature":"Fn(Expectation) -> Result<Unit, String>"}]},"IO":{"moduleName":"IO","items":[{"type":"value","name":"println","signature":"Fn(String) -> Task<Unit>"},{"type":"value","name":"print","signature":"Fn(String) -> Task<Unit>"},{"type":"value","name":"readline","signature":"Task<String>"},{"type":"value","name":"exit","signature":"Fn(Int) -> a"}]},"Test":{"moduleName":"Test","items":[{"type":"adt","name":"Test","params":[]},{"type":"value","name":"test","signature":"Fn(String, Expectation) -> Test"},{"type":"value","name":"concat","signature":"Fn(List<Test>) -> Test"},{"type":"value","name":"describe","signature":"Fn(String, List<Test>) -> Test"},{"type":"value","name":"run","signature":"Fn(Test) -> Task<Unit>"}]},"TestMain":{"moduleName":"TestMain","items":[{"type":"value","name":"main","signature":"Task<Unit>"}]}}}
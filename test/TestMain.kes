//// Internal module used for testing.
//// This will be removed in future versions of this package

import Bool.{Bool(..), (==), (||), (&&)}
import Char
import Debug
import Expect
import Float.{(+.)}
import Int.{(+), (*), (-), Int}
import List.{List}
import Option.{Option(..)}
import Result.{Result(..)}
import String.{String}
import Test
import Tuple.{Unit(..)}

let int_none: Option<Int> = None

let empty_int_list: List<Int> = []

let showable_err: Result<_, Int> = Ok(Some(42))

let debug_tests = Test.describe("Debug", [
  Test.describe("inspect", [
    Test.test("inspect True", || {
      True
      |> Debug.inspect()
      |> Expect.equal("True")
    }),
    Test.test("inspect False", || {
      False
      |> Debug.inspect()
      |> Expect.equal("False")
    }),
    Test.test("inspect int", || {
      42
      |> Debug.inspect()
      |> Expect.equal("42")
    }),
    Test.test("inspect float", || {
      42.2
      |> Debug.inspect()
      |> Expect.equal("42.2")
    }),
    Test.test("inspect float with trailing zero", || {
      42.0
      |> Debug.inspect()
      |> Expect.equal("42.0")
    }),
    Test.test("inspect Tuple2", || {
      (0, 42)
      |> Debug.inspect()
      |> Expect.equal("(0, 42)")
    }),
    Test.test("inspect Nil", || {
      empty_int_list
      |> Debug.inspect()
      |> Expect.equal("[]")
    }),
    Test.test("inspect Cons list", || {
      [1, 2, 3]
      |> Debug.inspect()
      |> Expect.equal("[1, 2, 3]")
    }),
    Test.test("inspect boxed value", || {
      Some(True)
      |> Debug.inspect()
      |> Expect.equal("Some(True)")
    }),
    Test.test("inspect singleton", || {
      int_none
      |> Debug.inspect()
      |> Expect.equal("None")
    }),
    Test.test("inspect strings", || {
      "abc"
      |> Debug.inspect()
      |> Expect.equal("\"abc\"")
    }),
    Test.test("inspect chars", || {
      Char.from_code(97)
      |> Debug.inspect()
      |> Expect.equal("\'a\'")
    }),
  ]),
])

let int_tests = Test.describe("Int", [
  Test.test("+ of ints", || {
    1 + 2
    |> Expect.equal(3)
  }),
])

let float_tests = Test.describe("Float", [
  Test.test("+. of floats", || {
    1.1 +. 2.1
    |> Expect.equal(3.2)
  }),
])

let bool_tests = Test.describe("Bool", [
  Test.describe("Logic &&", [
    Test.test("True && False", || {
      True && True
      |> Expect.equal(True)
    }),
    Test.test("True && False", || {
      True && False
      |> Expect.equal(False)
    }),
  ]),
  Test.describe("Logic ||", [
    Test.test("True || False", || {
      True || True
      |> Expect.equal(True)
    }),
    Test.test("True || False", || {
      True || False
      |> Expect.equal(True)
    }),
  ]),
  Test.describe("structural equality", [
    Test.test("of strings that are equal", || {
      Some("ab") == Some("ab")
      |> Expect.equal(True)
    }),
    Test.test("of strings that are not equal", || {
      Some("ab") == Some("abc")
      |> Expect.equal(False)
    }),
    Test.test("of chars that are equal", || {
      Some('a') == Some('a')
      |> Expect.equal(True)
    }),
    Test.test("of chars that are not equal", || {
      Some('a') == Some('b')
      |> Expect.equal(False)
    }),
    Test.test("of boxed type that are equal", || {
      Some(42) == Some(42)
      |> Expect.equal(True)
    }),
    Test.test("of boxed type that are not equal", || {
      Some(42) == Some(100)
      |> Expect.equal(False)
    }),
    Test.test("of nested types that are equal", || {
      showable_err == showable_err
      |> Expect.equal(True)
    }),
    Test.test("of different variants", || {
      Some(42) == None
      |> Expect.equal(False)
    }),
  ]),
])

let char_tests = Test.describe("Char", [
  Test.describe("from_code", [
    Test.test("of alpha char", || {
      let code = 123;
      Char.from_code(code)
      |> Char.to_code()
      |> Expect.equal(code)
    }),
  ]),
  Test.describe("to_code", [
    Test.test("of alpha char", || {
      Char.to_code('a')
      |> Expect.equal(97)
    }),
  ]),
  Test.describe("is_lower", [
    Test.test("returns True on lowercase chars", || {
      'x'
      |> Char.is_lower()
      |> Expect.equal(True)
    }),
    Test.test("returns False on uppercase chars", || {
      'X'
      |> Char.is_lower()
      |> Expect.equal(False)
    }),
  ]),
  Test.describe("is_upper", [
    Test.test("returns False on lowercase chars", || {
      'x'
      |> Char.is_upper()
      |> Expect.equal(False)
    }),
    Test.test("returns True on uppercase chars", || {
      'X'
      |> Char.is_upper()
      |> Expect.equal(True)
    }),
  ]),
  Test.describe("is_alpha", [
    Test.test("returns False on nums", || {
      '2'
      |> Char.is_alpha()
      |> Expect.equal(False)
    }),
    Test.test("returns True on letters", || {
      'x'
      |> Char.is_alpha()
      |> Expect.equal(True)
    }),
  ]),
])

let string_tests = Test.describe("String", [
  Test.describe("length", [
    Test.test("of a non-empty string", || {
      String.length("abc")
      |> Expect.equal(3)
    }),
  ]),
  Test.describe("char_at", [
    Test.test("is None when index is higher than string's lenght", || {
      String.char_at("abc", 3)
      |> Expect.equal(None)
    }),
    Test.test("is None when index is lower than 0", || {
      String.char_at("abc", 0 - 1)
      |> Expect.equal(None)
    }),
    Test.test("returns the char otherwise", || {
      String.char_at("abc", 1)
      |> Expect.equal(Some('b'))
    }),
  ]),
  Test.describe("parse_int", [
    Test.test("when the input is an int", || {
      String.parse_int("42")
      |> Expect.equal(Some(42))
    }),
    Test.test("when the input is not a number", || {
      String.parse_int("abc")
      |> Expect.equal(None)
    }),
    Test.test("when input is a float", || {
      String.parse_int("42.2")
      |> Expect.equal(None)
    }),
  ]),
  Test.describe("split", [
    Test.test("empty string", || {
      String.split("", "-")
      |> Expect.equal([""])
    }),
    Test.test("split string", || {
      String.split("ab-cde-fg", "-")
      |> Expect.equal(["ab", "cde", "fg"])
    }),
  ]),
  Test.describe("to_list", [
    Test.test("returns an empty list when string is empty", || {
      ""
      |> String.to_list()
      |> Expect.equal([])
    }),
    Test.test("returns the list of chars when string is not empty", || {
      "abc"
      |> String.to_list()
      |> Expect.equal(['a', 'b', 'c'])
    }),
  ]),
  Test.describe("from_list", [
    Test.test("returns an empty string from the empty list", || {
      []
      |> String.from_list()
      |> Expect.equal("")
    }),
    Test.test("returns a non empty str", || {
      ['a', 'b', 'c']
      |> String.from_list()
      |> Expect.equal("abc")
    }),
  ]),
  Test.describe("from_char", [
    Test.test("returns a string", || {
      'a'
      |> String.from_char()
      |> Debug.inspect()
      |> Expect.equal("\"a\"")
    }),
  ]),
])

let option_tests = Test.describe("Option", [
  Test.describe("map", [
    Test.test("of Some", || {
      Some(100)
      |> Option.map(|x| {
        x + 1
      })
      |> Expect.equal(Some(101))
    }),
    Test.test("of None", || {
      None
      |> Option.map(|x| {
        x + 1
      })
      |> Expect.equal(None)
    }),
  ]),
  Test.describe("map2", [
    Test.test("Some and Some", || {
      Option.map2(Some(10), Some(20), |a, b| {
        a + b
      })
      |> Expect.equal(Some(30))
    }),
    Test.test("None and Some", || {
      Option.map2(None, Some(20), |a, b| {
        a + b
      })
      |> Expect.equal(None)
    }),
  ]),
])

let list_tests = Test.describe("List", [
  Test.describe("List.range", [
    Test.test("empty", || {
      List.range(0, 2)
      |> Expect.equal([0, 1])
    }),
    Test.test("not empty", || {
      List.range(0, 3)
      |> Expect.equal([0, 1, 2])
    }),
  ]),
  Test.describe("List.find", [
    Test.test("on an empty list", || {
      List.find(empty_int_list, |_| {
        False
      })
      |> Expect.equal(None)
    }),
    Test.test("when value is not found", || {
      List.find([1, 2, 3], |_| {
        False
      })
      |> Expect.equal(None)
    }),
    Test.test("when value is found", || {
      List.find([1, 2, 3], |x| {
        x == 2
      })
      |> Expect.equal(Some(2))
    }),
  ]),
  Test.describe("List.map", [
    Test.test("empty", || {
      List.map([0, 1, 2], |x| {
        x * 10
      })
      |> Expect.equal([0, 10, 20])
    }),
    Test.test("not empty", || {
      List.range(0, 3)
      |> Expect.equal([0, 1, 2])
    }),
  ]),
  Test.describe("List.zip", [
    Test.test("when the first list is shorter, truncate the second", || {
      List.zip([0, 1], ["a", "b", "c", "d"])
      |> Expect.equal([(0, "a"), (1, "b")])
    }),
    Test.test("when the second list is shorter, truncate the first", || {
      List.zip([0, 1, 2], ["a"])
      |> Expect.equal([(0, "a")])
    }),
    Test.test("same len", || {
      List.zip([0, 1], ["a", "b"])
      |> Expect.equal([(0, "a"), (1, "b")])
    }),
  ]),
  Test.describe("List.reverse", [
    Test.test("on the empty list", || {
      List.reverse(empty_int_list)
      |> Expect.equal(empty_int_list)
    }),
    Test.test("on a non empty list", || {
      List.reverse([1, 2, 3])
      |> Expect.equal([3, 2, 1])
    }),
  ]),
  Test.describe("List comprehnsion", [
    Test.test("flat_map + guard", || {
      let comprehension = {
        let#List.flat_map x = [1, 2];
        let#List.flat_map y = ['a', 'b'];
        let#List.guard _unit = x == 1;
        [(x, y)]
      };
      Expect.equal(comprehension, [(1, 'a'), (1, 'b')])
    }),
  ]),
])

type Person struct {
  name: String,
  age: Int,
}

type Dog struct {
  name: String,
  age: Int,
}

let struct_tests = Test.describe("structs", [
  Test.test("read field", || {
    let p = Person {
      name: "hello",
      age: 42,
    };
    p.name
    |> Expect.equal("hello")
  }),
  Test.test("update struct", || {
    let p1 = Person {
      name: "hello",
      age: 42,
    };
    let p2 = Person {
      age: p1.age + 1,
      ..p1
    };
    p2.age
    |> Expect.equal(43)
  }),
])

pub let main = {
  [
    debug_tests,
    int_tests,
    float_tests,
    bool_tests,
    char_tests,
    string_tests,
    option_tests,
    list_tests,
    struct_tests,
  ]
  |> Test.concat()
  |> Test.run()
}

//// Internal module used for testing.
//// This will be removed in future versions of this package

import Bool.{Bool(..), (==), (||), (&&)}
import Char
import Debug
import Expect
import Float.{(+.)}
import Int.{(+), (*)}
import List
import Option.{Option(..)}
import Result.{Result(..)}
import String
import Task
import Test
import Tuple

let debug_tests = Test.describe("Debug", [
  Test.describe("inspect", [
    Test.test("inspect True", fn {
      True
      |> Debug.inspect()
      |> Expect.equal("True")
    }),
    Test.test("inspect False", fn {
      False
      |> Debug.inspect()
      |> Expect.equal("False")
    }),
    Test.test("inspect int", fn {
      42
      |> Debug.inspect()
      |> Expect.equal("42")
    }),
    Test.test("inspect float", fn {
      42.2
      |> Debug.inspect()
      |> Expect.equal("42.2")
    }),
    Test.test("inspect Tuple2", fn {
      (0, 42)
      |> Debug.inspect()
      |> Expect.equal("(0, 42)")
    }),
    Test.test("inspect Nil", fn {
      []
      |> Debug.inspect()
      |> Expect.equal("[]")
    }),
    Test.test("inspect Cons list", fn {
      [1, 2, 3]
      |> Debug.inspect()
      |> Expect.equal("[1, 2, 3]")
    }),
    Test.test("inspect boxed value", fn {
      Some(True)
      |> Debug.inspect()
      |> Expect.equal("Some(True)")
    }),
    Test.test("inspect singleton", fn {
      None
      |> Debug.inspect()
      |> Expect.equal("None")
    }),
    Test.test("inspect internal", fn {
      Task.none
      |> Debug.inspect()
      |> Expect.equal("<internals>")
    }),
    Test.test("inspect function", fn {
      Debug.inspect(fn {
        0
      })
      |> Expect.equal("#[Function]")
    }),
    Test.test("inspect strings", fn {
      "abc"
      |> Debug.inspect()
      |> Expect.equal("\"abc\"")
    }),
    Test.test("inspect chars", fn {
      Char.from_code(97)
      |> Debug.inspect()
      |> Expect.equal("\'a\'")
    }),
  ]),
])

let int_tests = Test.describe("Int", [
  Test.test("+ of ints", fn {
    1 + 2
    |> Expect.equal(3)
  }),
])

let float_tests = Test.describe("Float", [
  Test.test("+. of floats", fn {
    1.1 +. 2.1
    |> Expect.equal(3.2)
  }),
])

let bool_tests = Test.describe("Bool", [
  Test.describe("Logic &&", [
    Test.test("True && False", fn {
      True && True
      |> Expect.equal(True)
    }),
    Test.test("True && False", fn {
      True && False
      |> Expect.equal(False)
    }),
  ]),
  Test.describe("Logic ||", [
    Test.test("True || False", fn {
      True || True
      |> Expect.equal(True)
    }),
    Test.test("True || False", fn {
      True || False
      |> Expect.equal(True)
    }),
  ]),
  Test.describe("structural equality", [
    Test.test("of strings that are equal", fn {
      Some("ab") == Some("ab")
      |> Expect.equal(True)
    }),
    Test.test("of strings that are not equal", fn {
      Some("ab") == Some("abc")
      |> Expect.equal(False)
    }),
    Test.test("of chars that are equal", fn {
      Some('a') == Some('a')
      |> Expect.equal(True)
    }),
    Test.test("of chars that are not equal", fn {
      Some('a') == Some('b')
      |> Expect.equal(False)
    }),
    Test.test("of boxed type that are equal", fn {
      Some(42) == Some(42)
      |> Expect.equal(True)
    }),
    Test.test("of boxed type that are not equal", fn {
      Some(42) == Some(100)
      |> Expect.equal(False)
    }),
    Test.test("of nested types that are equal", fn {
      Ok(Some(42)) == Ok(Some(42))
      |> Expect.equal(True)
    }),
    Test.test("of different variants", fn {
      Some(42) == None
      |> Expect.equal(False)
    }),
  ]),
])

let char_tests = Test.describe("Char", [
  Test.describe("from_code", [
    Test.test("of alpha char", fn {
      let code = 123;
      Char.from_code(code)
      |> Char.to_code()
      |> Expect.equal(code)
    }),
  ]),
  Test.describe("to_code", [
    Test.test("of alpha char", fn {
      Char.to_code('a')
      |> Expect.equal(97)
    }),
  ]),
])

let string_tests = Test.describe("String", [
  Test.describe("length", [
    Test.test("of a non-empty string", fn {
      String.length("abc")
      |> Expect.equal(3)
    }),
  ]),
  Test.describe("parse_int", [
    Test.test("when the input is an int", fn {
      String.parse_int("42")
      |> Expect.equal(Some(42))
    }),
    Test.test("when the input is not a number", fn {
      String.parse_int("abc")
      |> Expect.equal(None)
    }),
    Test.test("when input is a float", fn {
      String.parse_int("42.2")
      |> Expect.equal(None)
    }),
  ]),
  Test.describe("split", [
    Test.test("empty string", fn {
      String.split("", "-")
      |> Expect.equal([""])
    }),
    Test.test("split string", fn {
      String.split("ab-cde-fg", "-")
      |> Expect.equal(["ab", "cde", "fg"])
    }),
  ]),
  Test.describe("from_char", [
    Test.test("returns a string", fn {
      'a'
      |> String.from_char()
      |> Debug.inspect()
      |> Expect.equal("\"a\"")
    }),
  ]),
])

let option_tests = Test.describe("Option", [
  Test.describe("map", [
    Test.test("of Some", fn {
      Some(100)
      |> Option.map(fn x {
        x + 1
      })
      |> Expect.equal(Some(101))
    }),
    Test.test("of None", fn {
      None
      |> Option.map(fn x {
        x + 1
      })
      |> Expect.equal(None)
    }),
  ]),
  Test.describe("map2", [
    Test.test("Some and Some", fn {
      Option.map2(Some(10), Some(20), fn a, b {
        a + b
      })
      |> Expect.equal(Some(30))
    }),
    Test.test("None and Some", fn {
      Option.map2(None, Some(20), fn a, b {
        a + b
      })
      |> Expect.equal(None)
    }),
  ]),
])

let list_tests = Test.describe("List", [
  Test.describe("List.range", [
    Test.test("empty", fn {
      List.range(0, 2)
      |> Expect.equal([0, 1])
    }),
    Test.test("not empty", fn {
      List.range(0, 3)
      |> Expect.equal([0, 1, 2])
    }),
  ]),
  Test.describe("List.find", [
    Test.test("on an empty list", fn {
      List.find([], fn _ {
        False
      })
      |> Expect.equal(None)
    }),
    Test.test("when value is not found", fn {
      List.find([1, 2, 3], fn _ {
        False
      })
      |> Expect.equal(None)
    }),
    Test.test("when value is found", fn {
      List.find([1, 2, 3], fn x {
        x == 2
      })
      |> Expect.equal(Some(2))
    }),
  ]),
  Test.describe("List.map", [
    Test.test("empty", fn {
      List.map([0, 1, 2], fn x {
        x * 10
      })
      |> Expect.equal([0, 10, 20])
    }),
    Test.test("not empty", fn {
      List.range(0, 3)
      |> Expect.equal([0, 1, 2])
    }),
  ]),
  Test.describe("List.zip", [
    Test.test("when the first list is shorter, truncate the second", fn {
      List.zip([0, 1], ["a", "b", "c", "d"])
      |> Expect.equal([(0, "a"), (1, "b")])
    }),
    Test.test("when the second list is shorter, truncate the first", fn {
      List.zip([0, 1, 2], ["a"])
      |> Expect.equal([(0, "a")])
    }),
    Test.test("same len", fn {
      List.zip([0, 1], ["a", "b"])
      |> Expect.equal([(0, "a"), (1, "b")])
    }),
  ]),
  Test.describe("List.reverse", [
    Test.test("on the empty list", fn {
      List.reverse([])
      |> Expect.equal([])
    }),
    Test.test("on a non empty list", fn {
      List.reverse([1, 2, 3])
      |> Expect.equal([3, 2, 1])
    }),
  ]),
  Test.describe("List comprehnsion", [
    Test.test("flat_map + guard", fn {
      let comprehension = {
        let#List.flat_map x = [1, 2];
        let#List.flat_map y = ['a', 'b'];
        let#List.guard _unit = x == 1;
        [(x, y)]
      };
      Expect.equal(comprehension, [(1, 'a'), (1, 'b')])
    }),
  ]),
])

pub let main = {
  [
    debug_tests,
    int_tests,
    float_tests,
    bool_tests,
    char_tests,
    string_tests,
    option_tests,
    list_tests,
  ]
  |> Test.concat()
  |> Test.run()
}
